use std::hash::Hash;
use std::marker::PhantomData;

use dashmap::DashMap;
use rayon::iter::{ParallelIterator, IntoParallelIterator};
use std::convert::identity;

/// Groups items by key.
/// After all items have been added, this structure can be transformed into
/// an iterator over groups.
/// The order of groups in the output iterator is not defined.
/// The order of items in each group matches the order of adding the items by a thread.
/// Items can be added from multiple threads.
///
/// Internally uses a concurrent hash map.
/// The amortized complexity of adding an item is O(1).
/// The complexity of reading all groups is O(N).
///
/// # Example
/// ```
/// use dff::group::GroupMap;
/// let map = GroupMap::new(|item: (u32, u32)| (item.0, item.1));
/// map.add((1, 10));
/// map.add((2, 20));
/// map.add((1, 11));
/// map.add((2, 21));
///
/// let mut groups: Vec<_> = map.into_iter().collect();
///
/// groups.sort_by_key(|item| item.0);
/// assert_eq!(groups[0], (1, vec![10, 11]));
/// assert_eq!(groups[1], (2, vec![20, 21]));
/// ```
///
pub struct GroupMap<T, K, V, F>
    where K: PartialEq + Hash,
          F: Fn(T) -> (K, V)
{
    item_type: PhantomData<T>,
    groups: DashMap<K, Vec<V>>,
    split_fn: F,
}

impl<T, K, V, F> GroupMap<T, K, V, F>
    where K: Eq + Hash,
          F: Fn(T) -> (K, V),
{
    /// Creates a new empty map.
    ///
    /// # Arguments
    /// * `split_fn` - a function generating the key-value pair for each input item
    pub fn new(split_fn: F) -> GroupMap<T, K, V, F> {
        GroupMap { item_type: PhantomData, groups: DashMap::new(), split_fn }
    }

    /// Adds an item to the map.
    /// Note, this doesn't take `&mut self` so this can be called from safely from many threads.
    pub fn add(&self, item: T) {
        let (key, new_item) = (self.split_fn)(item);
        self.groups
            .entry(key)
            .or_insert(vec![])
            .push(new_item);
    }
}

impl<T, K, V, F> IntoIterator for GroupMap<T, K, V, F>
    where K: Eq + Hash,
          F: Fn(T) -> (K, V),
{
    type Item = (K, Vec<V>);
    type IntoIter = <DashMap<K, Vec<V>> as IntoIterator>::IntoIter;

    fn into_iter(self) -> Self::IntoIter {
        self.groups.into_iter()
    }
}

/// Implemented by collections of items that can be grouped in parallel according to some key.
/// The value of the key for each item is provided by a key-generating function.
///
/// # Example
/// ```
/// use rayon::prelude::*;
/// use dff::group::*;
/// use std::convert::identity;
///
/// let mut groups: Vec<_> = vec![(1, 10), (2, 20), (1, 11), (2, 21)]
///     .into_par_iter()
///     .group_by_key(identity)
///     .into_iter()
///     .collect();
///
/// // The results may come in any order, so let's make them deterministic:
/// groups.sort_by_key(|item| item.0);
/// groups[0].1.sort();
/// groups[1].1.sort();
///
/// assert_eq!(groups[0], (1, vec![10, 11]));
/// assert_eq!(groups[1], (2, vec![20, 21]));
///
/// ```
pub trait GroupByKey<T> {
    fn group_by_key<K, V, F>(self, f: F) -> GroupMap<T, K, V, F>
        where K: Eq + Hash + Sync + Send,
              V: Send + Sync,
              F: (Fn(T) -> (K, V)) + Sync;
}

impl<T, In> GroupByKey<T> for In
    where T: Sync + Send, In: ParallelIterator<Item=T>
{
    fn group_by_key<K, V, F>(self, f: F) -> GroupMap<T, K, V, F>
        where K: Eq + Hash + Sync + Send,
              V: Send + Sync,
              F: (Fn(T) -> (K, V)) + Sync
    {
        let grouping_map = GroupMap::new(f);
        self.for_each(|item| grouping_map.add(item));
        grouping_map
    }
}

/// Split a collection of groups `(K1, I)` into a collection of smaller
/// groups `(K2, Vec<V>)` according to a key generated by `group_by` function.
/// The items for which the grouping function returns `None` are not further processed.
/// Finally only groups larger than `min_groups_size` are kept in the output.
///
/// This method does not merge groups together. If items in two different input groups
/// generate the same key, they will remain in separate groups in the output.
///
/// The operation is performed in parallel, so all arguments must be thread-safe.
/// The order of items in the output is unspecified and must not be relied upon.
///
/// # Example
/// ```
/// use dff::group::split_groups;
///
/// let input = vec![
///     ("a", vec![1, -5, 12, 9]),
///     ("b", vec![-2, -5, 3])
/// ];
/// let mut output = split_groups(input, 1, |&k, &v| Some((k, v >= 0)));
/// output.sort_by_key(|g| g.0);
/// output.iter_mut().for_each(|x| x.1.sort());
///
/// assert_eq!(output, vec![
///     (("a", false), vec![-5]),
///     (("a", true),  vec![1, 9, 12]),
///     (("b", false), vec![-5, -2]),
///     (("b", true),  vec![3]),
/// ]);
/// ```
pub fn split_groups<K1, K2, V, F, I>(input: Vec<(K1, I)>, min_group_size: usize, group_by: F)
    -> Vec<(K2, Vec<V>)>
    where K1: Eq + Hash + Sync + Send,
          K2: Eq + Hash + Sync + Send,
          V: Sync + Send,
          F: Fn(&K1, &V) -> Option<K2> + Sync + Send,
          I: IntoParallelIterator<Item=V> + Send
{
    input
        .into_par_iter()
        .flat_map(|(k1, values)| {
            values
                .into_par_iter()
                .filter_map(|v| (group_by)(&k1, &v).map(|k2| (k2, v)))
                .group_by_key(identity)
                .into_iter()
                .filter(|(_, values)| values.len() >= min_group_size)
                .collect::<Vec<_>>()
        })
        .collect::<Vec<_>>()
}
